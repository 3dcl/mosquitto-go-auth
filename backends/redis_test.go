package backends

import (
	. "github.com/smartystreets/goconvey/convey"
	"testing"
)

func TestRedis(t *testing.T) {

	//Initialize Redis with some test values.
	authOpts := make(map[string]string)
	authOpts["redis_host"] = "localhost"
	authOpts["redis_port"] = "6379"
	authOpts["redis_db"] = "2"

	Convey("Given valid params NewRedis should return a Redis backend instance", t, func() {
		redis, err := NewRedis(authOpts)
		So(err, ShouldBeNil)

		//Empty db
		redis.Conn.FlushDB()

		//Insert a user to test auth
		username := "test"
		userPass := "testpw"
		//Hash generated by the pw utility
		userPassHash := "PBKDF2$sha512$100000$os24lcPr9cJt2QDVWssblQ==$BK1BQ2wbwU1zNxv3Ml3wLuu5//hPop3/LvaPYjjCwdBvnpwusnukJPpcXQzyyjOlZdieXTx6sXAcX4WnZRZZnw=="

		redis.Conn.Set(username, userPassHash, 0)

		Convey("Given a username and a correct password, it should correctly authenticate it", func() {

			authenticated := redis.GetUser(username, userPass)
			So(authenticated, ShouldBeTrue)

		})

		Convey("Given a username and an incorrect password, it should not authenticate it", func() {

			authenticated := redis.GetUser(username, "wrong_password")
			So(authenticated, ShouldBeFalse)

		})

		redis.Conn.Set(username+":su", "true", 0)
		Convey("Given a username that is superuser, super user check should pass", func() {
			superuser := redis.GetSuperuser(username)
			So(superuser, ShouldBeTrue)
		})

		//Now create some acls and test topics

		strictAcl := "test/topic/1"
		singleLevelAcl := "test/topic/+"
		hierarchyAcl := "test/#"

		userPattern := "test/%u"
		clientPattern := "test/%c"

		clientID := "test_client"

		redis.Conn.SAdd(username+":acls", strictAcl)

		Convey("Given only strict acl in DB, an exact match should work and and inexact one not", func() {

			testTopic1 := `test/topic/1`
			testTopic2 := `test/topic/2`

			tt1 := redis.CheckAcl(username, testTopic1, clientID, 1)
			tt2 := redis.CheckAcl(username, testTopic2, clientID, 1)

			So(tt1, ShouldBeTrue)
			So(tt2, ShouldBeFalse)

		})

		Convey("Given wildcard subscriptions against strict db acl, acl checks should fail", func() {

			tt1 := redis.CheckAcl(username, singleLevelAcl, clientID, 1)
			tt2 := redis.CheckAcl(username, hierarchyAcl, clientID, 1)

			So(tt1, ShouldBeFalse)
			So(tt2, ShouldBeFalse)

		})

		//Now check against patterns.

		redis.Conn.SAdd(username+":acls", userPattern)

		Convey("Given a topic that mentions username, acl check should pass", func() {
			tt1 := redis.CheckAcl(username, "test/test", clientID, 1)
			So(tt1, ShouldBeTrue)
		})

		redis.Conn.SAdd(username+":acls", clientPattern)

		Convey("Given a topic that mentions clientid, acl check should pass", func() {
			tt1 := redis.CheckAcl(username, "test/test_client", clientID, 1)
			So(tt1, ShouldBeTrue)
		})

		//Now insert single level topic to check against.

		redis.Conn.SAdd(username+":acls", singleLevelAcl)

		Convey("Given a topic not strictly present that matches a db single level wildcard, acl check should pass", func() {
			tt1 := redis.CheckAcl(username, "test/topic/whatever", clientID, 1)
			So(tt1, ShouldBeTrue)
		})

		//Now insert hierarchy wildcard to check against.

		redis.Conn.SAdd(username+":acls", hierarchyAcl)

		Convey("Given a topic not strictly present that matches a hierarchy wildcard, acl check should pass", func() {
			tt1 := redis.CheckAcl(username, "test/what/ever", clientID, 1)
			So(tt1, ShouldBeTrue)
		})

		//Empty db
		//redis.Conn.FlushDB()

	})

}
