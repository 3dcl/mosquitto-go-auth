package backends

import (
	jwt "github.com/dgrijalva/jwt-go"
	. "github.com/smartystreets/goconvey/convey"
	"testing"
	"time"
)

func TestJWT(t *testing.T) {

	username := "test"
	//Hash generated by the pw utility
	userPassHash := "PBKDF2$sha512$100000$os24lcPr9cJt2QDVWssblQ==$BK1BQ2wbwU1zNxv3Ml3wLuu5//hPop3/LvaPYjjCwdBvnpwusnukJPpcXQzyyjOlZdieXTx6sXAcX4WnZRZZnw=="

	jwtSecret := "some_jwt_secret"

	// Generate the token.
	now := time.Now()
	nowSecondsSinceEpoch := now.Unix()
	var expSecondsSinceEpoch int64
	expSecondsSinceEpoch = nowSecondsSinceEpoch + int64(time.Hour*24/time.Second)

	jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"iss":      "jwt-test",
		"aud":      "jwt-test",
		"nbf":      nowSecondsSinceEpoch,
		"exp":      expSecondsSinceEpoch,
		"sub":      "user",
		"username": username,
	})

	wrongJwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"iss":      "jwt-test",
		"aud":      "jwt-test",
		"nbf":      nowSecondsSinceEpoch,
		"exp":      expSecondsSinceEpoch,
		"sub":      "user",
		"username": "wrong_user",
	})

	Convey("Creating a token should return a nil error", t, func() {
		token, err := jwtToken.SignedString([]byte(jwtSecret))
		So(err, ShouldBeNil)

		//Initialize JWT in local mode.
		authOpts := make(map[string]string)
		authOpts["jwt_remote"] = "false"
		authOpts["jwt_secret"] = jwtSecret
		authOpts["jwt_userquery"] = "select count(*) from test_user where username = $1 limit 1"
		authOpts["jwt_superquery"] = "select count(*) from test_user where username = $1 and is_admin = true"
		authOpts["jwt_aclquery"] = "SELECT test_acl.topic FROM test_acl, test_user WHERE test_user.username = $1 AND test_acl.test_user_id = test_user.id AND rw >= $2"
		authOpts["pg_userquery"] = "mock_string"
		authOpts["pg_superquery"] = "mock_string"
		authOpts["pg_aclquery"] = "mock_string"

		//Give necessary postgres options.
		authOpts["pg_host"] = "localhost"
		authOpts["pg_port"] = "5432"
		authOpts["pg_dbname"] = "go_auth_test"
		authOpts["pg_user"] = "go_auth_test"
		authOpts["pg_password"] = "go_auth_test"

		Convey("Given correct option NewJWT returns an instance of jwt backend", func() {
			jwt, err := NewJWT(authOpts)
			So(err, ShouldBeNil)

			//Empty DB
			jwt.Postgres.DB.MustExec("delete from test_user where 1 = 1")
			jwt.Postgres.DB.MustExec("delete from test_acl where 1 = 1")

			//Now test everything.

			insertQuery := "INSERT INTO test_user(username, password_hash, is_admin) values($1, $2, $3) returning id"

			userID := 0

			iqErr := jwt.Postgres.DB.Get(&userID, insertQuery, username, userPassHash, true)

			So(iqErr, ShouldBeNil)
			So(userID, ShouldBeGreaterThan, 0)

			Convey("Given a correct token, it should correctly authenticate it", func() {

				authenticated := jwt.GetUser(token, "")
				So(authenticated, ShouldBeTrue)

			})

			Convey("Given an incorrect token, it should not authenticate it", func() {

				wrongToken, err := wrongJwtToken.SignedString([]byte(jwtSecret))
				So(err, ShouldBeNil)

				authenticated := jwt.GetUser(wrongToken, "")
				So(authenticated, ShouldBeFalse)

			})

			Convey("Given a token that is admin, super user should pass", func() {
				superuser := jwt.GetSuperuser(token)
				So(superuser, ShouldBeTrue)
			})

			//Now create some acls and test topics

			strictAcl := "test/topic/1"
			singleLevelAcl := "test/topic/+"
			hierarchyAcl := "test/#"

			clientID := "test_client"

			aclID := 0
			aclQuery := "INSERT INTO test_acl(test_user_id, topic, rw) values($1, $2, $3) returning id"
			aqErr := jwt.Postgres.DB.Get(&aclID, aclQuery, userID, strictAcl, 1)
			So(aqErr, ShouldBeNil)

			Convey("Given only strict acl in DB, an exact match should work and and inexact one not", func() {

				testTopic1 := `test/topic/1`
				testTopic2 := `test/topic/2`

				tt1 := jwt.CheckAcl(token, testTopic1, clientID, 1)
				tt2 := jwt.CheckAcl(token, testTopic2, clientID, 1)

				So(tt1, ShouldBeTrue)
				So(tt2, ShouldBeFalse)

			})

			Convey("Given read only privileges, a pub check should fail", func() {

				testTopic1 := "test/topic/1"
				tt1 := jwt.CheckAcl(token, testTopic1, clientID, 2)
				So(tt1, ShouldBeFalse)

			})

			Convey("Given wildcard subscriptions against strict db acl, acl checks should fail", func() {

				tt1 := jwt.CheckAcl(token, singleLevelAcl, clientID, 1)
				tt2 := jwt.CheckAcl(token, hierarchyAcl, clientID, 1)

				So(tt1, ShouldBeFalse)
				So(tt2, ShouldBeFalse)

			})

			//Now insert single level topic to check against.

			aqErr = jwt.Postgres.DB.Get(&aclID, aclQuery, userID, singleLevelAcl, 1)
			So(aqErr, ShouldBeNil)

			Convey("Given a topic not strictly present that matches a db single level wildcard, acl check should pass", func() {
				tt1 := jwt.CheckAcl(token, "test/topic/whatever", clientID, 1)
				So(tt1, ShouldBeTrue)
			})

			//Now insert hierarchy wildcard to check against.

			aqErr = jwt.Postgres.DB.Get(&aclID, aclQuery, userID, hierarchyAcl, 1)
			So(aqErr, ShouldBeNil)

			Convey("Given a topic not strictly present that matches a hierarchy wildcard, acl check should pass", func() {
				tt1 := jwt.CheckAcl(token, "test/what/ever", clientID, 1)
				So(tt1, ShouldBeTrue)
			})

			//Empty db
			jwt.Postgres.DB.MustExec("delete from test_user where 1 = 1")
			jwt.Postgres.DB.MustExec("delete from test_acl where 1 = 1")

		})

	})

}
